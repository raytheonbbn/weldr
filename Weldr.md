# Weldr: Fusing Binaries for Fun and Profit
## Concept
Modern binary analysis tools are powerful, but they are primarily geared towards analyzing the behavior of a single binary in isolation.  They tend to share two downfalls: dynamic libraries, and IPC.  Both downfalls stem from the same source; the code involved is extremely complicated, and tends to rely on kernel functionality invisible from userspace, and also exceptionally complicated to model.

To date, most solutions rely on light-weight modeling, using light-weight stub functionality to patch up a binary to the point where the analyzer doesn't fail.   This works well if you are looking for faults solely within the context of a single binary and its behaviors.  However, this doesn't work for analyzing a multi-binary system, since interesting behaviors can't be analyzed from the context of any single binary.

Weldr's approach is to use static linking to bring an entire system within scope of a single-binary analyzer.  Instead of forcing a single-binary analyzer to ingest multiple binaries, Weldr rebuilds all programs in the system into a single, monolithic binary, with high-fidelity, analyzer-friendly models replacing critical library functionality.  This way, tracing data flow across an IPC-linked system is reduced to tracing data flow between memory buffers in a single address space, which is a problem that existing tools can solve.

## Binary Architecture
### Generated Driver Code
The entry point of a Weldr-generated binary is a main function automatically generated by the framework.  This function's job is to initialize any model libraries, and then execute each sub-program in its own thread.

### Isolated Sub-programs
The core work of a Weldr-generated binary gets done in several child threads, one for each program in the original system.  Weldr uses a human-written system definition script to determine which programs get integrated, and how many instances of each programs should be launched.  Weldr's goal is to mimic the isolation of multiple running processes as closely as possible.  As stated above, each sub-process runs concurrently in its own thread.  Additionally, the binary construction scripts deconflict the linker symbols used by each sub-program, creating a unique object file for each instance with guaranteed-unique function and global names, ensuring that each sub-program will not touch the data or code of any other, except as moderated by IPC models.

### Per-sub-program Library Models
When Weldr builds its sub-program instances, it may also add library models to each instance.  These are known as "stub libraries;" they directly override dynamic symbols in order to inject model functionality.  These libraries go through the same deconfliction process as the sub-programs, so if there are N sub-programs, there will be N independent copies of each stub library, each using a different set of function and variable symbols to hook into a single sub-program.  This is useful for modifying functionality on a per-sub-program basis to correct for environmental differences.

- **Standard streams:** The only model of this kind implemented right now splits stdin/stdout/stderr for the separate sub-programs into different file descriptors.  Without this, it would be impossible for a user to direct stdin input to a specific sub-program, and difficult to differentiate whether output came from a particular sub-program, or from the fusion infrastructure itself.

### Whole-system Library Models
Weldr allows a second method of library injection at link-time.  These are known as "wrapper libraries"; they use ld's -wrap argument to replace symbols across the entire fused binary with wrapper implementations.  Unlike stub libraries, these aren't deconflicted; the whole binary shares one copy of a wrapper library's code and data, which is useful for modeling the host environment through which the sub-programs communicate.

- **libpthread:** The most critical library model in all of Weldr is a user-space model of libpthread.  Running multiple programs within a single process space is exactly what multi-threading is used for; the generated driver code implements its sub-programs as pthreads.  However, actual multi-threading code is heavily dependent on opaque kernel functionality, and is extremely difficult to model in an analysis environment.  Weldr includes a custom user thread library designed to wrap libpthread's existing API.  This library mimics multi-threaded behavior as closely as possible, while operating in a single thread and keeping its constructs as simple to analyze as possible.
- **IPC models:** The other whole-system models will handle individual IPC mechanisms.  Each library will wrap the existing libc interfaces for a given IPC mechanism, and replace the library code and hardware operations with a model that transmits data between sub-programs using only process memory.
- **Static Inclusions:** Some libraries, especially libstdc++, don't need to be altered directly, but they do need to be included as static libraries in order for the wrapper libraires to apply correctly.  These are known as "Include libraries;" all you do is include them.

## System Workflow
### Phase 1: Recover Build Artifacts
The first step of fusing a system is to recover the build artifacts of each program within the system.  Specifically, this means capturing the object files and linker arguments as each is compiled.  This is currently possible for Make-based systems that use the standard compiler macros; Weldr overrides the CC and CXX variables to invoke a shell script that interprets the gcc/ld flags and identifies intermediate object files.  The object files and compiler flags are saved to their own folder within Weldr's working directory.

### Phase 2: Embed System Architecture
Once Weldr has recovered the compiler artifacts for each program, it organizes them according to a human-defined system definition.  The system definition file takes the form of a series of program execution commands.  Every time a given program is "called" in the definition file, Weldr creates a copy of that program's working directory and assigns it a unique instance ID.  The object files for any stub libraries are added to these instance directories as they are created. 

### Phase 3: Deconflict Linker Symbols
Now that the sub-program instances are organized, Weldr modifies their object files to deconflict linker symbols.  Using objdump, Weldr scans each object file and compiles a list of symbol definitions and references for every sub-program.  If two or more sub-programs define the same symbol, Weldr uses objcopy to modify the objects for those programs, redefining that symbol with a unique name for each sub-program.  In this way, the sub-programs will not cause conflicts when statically linked. 

### Phase 4: Generate Driver Code
Once symbol deconfliction is done, the sub-programs are ready to be linked into a single binary.  To coordinate execution, Weldr automatically generates a C source file based on the model libraries requested and the sub-programs present.  This file contains a single main function that invokes the initializers for each library, and launches each sub-program.  This source file then gets compiled to its own object.

### Phase 5: Compile Fused Binary
At this point, all objects are ready to be statically linked into a single executable.  This stage is actually rather simple; it's a single call to gcc across all of the object files.  It's also at this point that any wrapper libraries are applied; each wrapper library defines a list of symbols that need to be redefined using the -wrap argument.  These -wrap commands are prepended to the gcc command, and the relevant static libraries are added to the list of input artifacts.  The result of this is a single binary that contains code for invoking the entire multi-process system in a single process space.

## Development Plan
### Implement Basic Use Case
The following steps are code-complete, and being tested. 

- **Implement System Workflow:**  The five phases of Weldr are implemented as a bash 4 command-line utility.  This means it is currently restricted to linux systems only. 
- **Implement Standard Stream Stubs:** Standard IO streams are redefined in a stub-library, as described above.
- **Implement Socket IPC model:** For demonstration purposes, the initial system includes a basic model of IPC via TCP sockets.
- **Implement libpthread model:** As stated above, the user-space threading library is critical to feeding a fused binary into a static analysis tool.  It's designed and implemented, and currently being tested. 
### Integrate with Analyzer
- **Run Analyzer-Friendly Tests** The first step in integrating with a symbolic or concolic execution tool is try and implement and solve a capture-the-flag style test in a fused binary.  There are good tutorials on how to analyze this kind of program, so we can focus on making Weldr's models work smoothly with the tool.
- **Explore Project Use Case** Once we know that a given tool can analyze a fused binary, the next step is to figure out how to get the tool to do what we really need it to do, which is identify symbolic representations of IPC protocols in all possible states of the protocol.
### Expand IPC Models
- **Identify more IPC mechanisms to model:** TCP sockets are a first test, but they are not the only means by which programs communicate.  As we identify useful IPC mechanisms, we need to add library models to handle them.  Two good examples might be named fifos, which are used heavily by ITOS; and stream redirection, which is common in Linux in general.
### Expand Accepted Systems
- **Expand System Definition Language:** Currently, the system definition language is little more than a list of programs to include in the model.  We may want to add features such as argument passing, execution dependencies, and stream redirects.
- **Revert Executables/Libraries to Objects:** Currently, Weldr needs to have source code in order to operate.  However, because it works exclusively off of undefined symbol resolution, it may be possible to revert ELF executables or shared objects into pseudo-object files that can be re-linked into a fused binary.  This would allow Weldr to operate on systems where we only have compiled binaries. 
### Handle C++
This turned out to be a lot easier than suspected.  Most C++ libraries ride directly on top of C APIs.  Model C accurately enough, and C++ follows naturally.

If we try to handle already-compiled artifacts, C++ object files use more features of the ELF format, defining extra code and data sections to define different parts of each class.  This complicates the process of reverting a linked binary, since these sections are lost once static linking is complete.

----------
Copyright (c) Raytheon BBN Technologies 2021, All Rights Reserved

This document does not contain technology or Technical Data controlled under either
the U.S. International Traffic in Arms Regulations or the U.S. Export Administration

Distribution A: Approved for Public Release, Distribution Unlimited
